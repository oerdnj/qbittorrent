Author: Cristian Greco <cristian@regolo.cc>
Description: backport r3710 from upstream svn - Save fast resume data every 3
minutes.

--- a/src/bittorrent.cpp
+++ b/src/bittorrent.cpp
@@ -31,7 +31,6 @@
 #include <QDir>
 #include <QDateTime>
 #include <QString>
-#include <QTimer>
 #include <QSettings>
 #include <stdlib.h>
 
@@ -132,6 +131,8 @@
   timerAlerts = new QTimer();
   connect(timerAlerts, SIGNAL(timeout()), this, SLOT(readAlerts()));
   timerAlerts->start(3000);
+  connect(&resumeDataTimer, SIGNAL(timeout()), this, SLOT(saveTempFastResumeData()));
+  resumeDataTimer.start(180000); // 3min
   // To download from urls
   downloader = new downloadThread(this);
   connect(downloader, SIGNAL(downloadFinished(QString, QString)), this, SLOT(processDownloadedFile(QString, QString)));
@@ -1393,10 +1394,23 @@
   return ratio;
 }
 
+void Bittorrent::saveTempFastResumeData() {
+  std::vector<torrent_handle> torrents =  s->get_torrents();
+  std::vector<torrent_handle>::iterator torrentIT;
+  for(torrentIT = torrents.begin(); torrentIT != torrents.end(); torrentIT++) {
+    QTorrentHandle h = QTorrentHandle(*torrentIT);
+    if(!h.is_valid() || !h.has_metadata() || h.is_seed() || h.is_paused()) continue;
+    if(h.state() == torrent_status::checking_files || h.state() == torrent_status::queued_for_checking) continue;
+    qDebug("Saving fastresume data for %s", qPrintable(h.name()));
+    h.save_resume_data();
+  }
+}
+
 // Only save fast resume data for unfinished and unpaused torrents (Optimization)
 // Called periodically and on exit
 void Bittorrent::saveFastResumeData() {
   // Stop listening for alerts
+  resumeDataTimer.stop();
   timerAlerts->stop();
   int num_resume_data = 0;
   // Pause session
@@ -1985,12 +1999,9 @@
         }
       }
 #endif
-      /*else if (torrent_paused_alert* p = dynamic_cast<torrent_paused_alert*>(a.get())) {
-      QTorrentHandle h(p->handle);
-      if(h.is_valid()) {
-        emit torrentPaused(h);
+      else if (torrent_paused_alert* p = dynamic_cast<torrent_paused_alert*>(a.get())) {
+        p->handle.save_resume_data();
       }
-    }*/
       else if (tracker_error_alert* p = dynamic_cast<tracker_error_alert*>(a.get())) {
         // Level: fatal
         QTorrentHandle h(p->handle);
--- a/src/bittorrent.h
+++ b/src/bittorrent.h
@@ -41,6 +41,7 @@
 #include <QPalette>
 #endif
 #include <QPointer>
+#include <QTimer>
 
 #include <libtorrent/session.hpp>
 #include <libtorrent/ip_filter.hpp>
@@ -194,6 +195,7 @@
   void deleteBigRatios();
   void takeETASamples();
   void exportTorrentFiles(QString path);
+  void saveTempFastResumeData();
 
 signals:
   void addedTorrent(QTorrentHandle& h);
@@ -222,6 +224,7 @@
   QMap<QUrl, QString> savepath_fromurl;
   QHash<QString, QHash<QString, TrackerInfos> > trackersInfos;
   QStringList torrentsToPausedAfterChecking;
+  QTimer resumeDataTimer;
   // Ratio
   QPointer<QTimer> BigRatioTimer;
   // HTTP
